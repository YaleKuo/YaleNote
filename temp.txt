TODO：
	3/1报名		国庆/大数据		1800题	人文	a.md	速读	俯卧撑	项目	cmsblogs	211111	
	SpringCloud技术组成		Mybatis/Spring用到的多线程	https://blog.csdn.net/Evankaka?type=blog	
	递归/队列	快排
	np.linspace		np.linalg	vscode打开jupyter notebook



—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


子类A继承父类B, A a = new A(); 则父类B构造函数、父类B静态代码块、父类B非静态代码块、子类A构造函数、子类A静态代码块、子类A非静态代码块 执行的先后顺序是？
父类Ｂ静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;子类Ａ构造函数-&gt;子类Ａ非静态代码块
父类Ｂ静态代码块-&gt;父类Ｂ构造函数-&gt;父类Ｂ非静态代码块-&gt;子类Ａ静态代码块-&gt;子类Ａ构造函数-&gt;子类Ａ非静态代码块
父类Ｂ静态代码块-&gt;子类Ａ静态代码块-&gt;父类Ｂ非静态代码块-&gt;父类Ｂ构造函数-&gt;子类Ａ非静态代码块-&gt;子类Ａ构造函数
父类Ｂ构造函数-&gt;父类Ｂ静态代码块-&gt;父类Ｂ非静态代码块-&gt;子类Ａ静态代码块-&gt;子类Ａ构造函数-&gt;子类Ａ非静态代码块
class SuperClass {
    private static String STR = "Super Class Static Variable";

    static {
        System.out.println("Super Class Static Block:" + STR);
    }

    public SuperClass() {
        System.out.println("Super Class Constructor Method");
    }

    {
        System.out.println("Super Class Block");
    }
}
public class ObjectInit extends SuperClass {
    private static String STR = "Class Static Variable";

    static {
        System.out.println("Class Static Block:" + STR);
    }

    public ObjectInit() {
        System.out.println("Constructor Method");
    }

    {
        System.out.println("Class Block");
    }

    public static void main(String[] args) {
        @SuppressWarnings("unused")
        ObjectInit a = new ObjectInit();
    }
}

在上下文和头文件正常的情况下，代码
System.out.println(10%3*2);
将打印？
1
2
4
6

以下说法错误的是？
数组是一个对象
数组不是一种原生类
数组的大小可以任意改变
在Java中，数组存储在堆中连续内存空间里

下列说法正确的是？
volatile,synchronized<br />都可以修改变量，方法以及代码块
volatile，synchronized 在多线程中都会存在阻塞问题
volatile能保证数据的可见性，但不能完全保证数据的原子性，synchronized即保证了数据的可见性也保证了原子性
volatile解决的是变量在多个线程之间的可见性、原子性，而sychroized解决的是多个线程之间访问资源的同步性

下面说法正确的是？
调用Thread的sleep()方法会释放锁，调用wait()方法不释放锁
一个线程调用yield方法，可以使具有相同优先级线程获得处理器
在Java中，高优先级的可运行的线程会抢占低优先级线程的资源
java中，线程可以调用yield方法使比自己低优先级的线程运行

下列说法正确的是？
对于局部内部类，只有在方法的局部变量被标记为final或局部变量是effctively final的，内部类才能使用它们
成员内部类位于外部类内部，可以直接调用外部类的所有方法（静态方法和非静态方法）
由于匿名内部类只能用在方法内部，所以匿名内部类的用法与局部内部类是一致的
静态内部类可以直接访问外部类的非静态成员

public static void main(String args[])throws InterruptedException{
   	Thread t=new Thread(new Runnable() {
		public void run() {
			try {
				Thread.sleep(2000);
			} catch (InterruptedException e) {
				throw new RuntimeException(e);
			}
			System.out.print("2");
		}
	});
   	t.start();
   	t.join();
   	System.out.print("1");
}
21
12
可能为12，也可能为21
以上答案都不对

下面哪个行为被打断不会导致InterruptedException？
Thread.join
Thread.sleep
Object.wait
CyclicBarrier.await
Thread.suspend

https://blog.csdn.net/ThinkWon/article/details/102021274?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166342830716800180679641%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166342830716800180679641&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-102021274-null-null.nonecase&utm_term=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1018.2226.3001.4450
public class MultiThread {
	public static void main(String[] args) {
		// 获取 Java 线程管理 MXBean
		ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();
		// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息
		ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(false, false);
		// 遍历线程信息，仅打印线程 ID 和线程名称信息
		for (ThreadInfo threadInfo : threadInfos) {
			System.out.println("[" + threadInfo.getThreadId() + "] " + threadInfo.getThreadName());
		}
	}
}

https://blog.csdn.net/ThinkWon/article/details/102020811?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166342830716800180679641%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166342830716800180679641&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-2-102020811-null-null.nonecase&utm_term=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1018.2226.3001.4450
public class DeadLockDemo {
    private static String resource_a = "A";
    private static String resource_b = "B";

    public static void main(String[] args) {
        deadLock();
    }

    public static void deadLock() {
        Thread threadA = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resource_a) {
                    System.out.println("get resource a");
                    try {
                        Thread.sleep(3000);
                        synchronized (resource_b) {
                            System.out.println("get resource b");
                        }
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
            }
        });
        Thread threadB = new Thread(new Runnable() {
            @Override
            public void run() {
                synchronized (resource_b) {
                    System.out.println("get resource b");
                    synchronized (resource_a) {
                        System.out.println("get resource a");
                    }
                }
            }
        });
        threadA.start();
        threadB.start();

    }
}




https://blog.csdn.net/weixin_43884234/article/details/114954221?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166342645116800182123502%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166342645116800182123502&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-1-114954221-null-null.nonecase&utm_term=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1018.2226.3001.4450
package cn.tedu.thread;
/*本类用于多线程编程实现方案一：继承Thread类来完成*/
public class TestThread1 {
    public static void main(String[] args) {
        //4.创建线程对象进行测试
        /*4.new对应的是线程的新建状态
        * 5.要想模拟多线程，至少得启动2个线程，如果只启动1个，是单线程程序*/
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        MyThread t3 = new MyThread();
        MyThread t4 = new MyThread();
        /*6.这个run()如果直接这样调用，是没有多线程抢占执行的效果的
        * 只是把这两句话看作普通方法的调用，谁先写，就先执行谁*/
        //t1.run();
        //t2.run();
        /*7.start()对应的状态就是就绪状态，会把刚刚新建好的线程加入到就绪队列之中
        * 至于什么时候执行，就是多线程执行的效果，需要等待OS选中分配CPU
        * 8.执行的时候start()底层会自动调用我们重写的run()种的业务
        * 9.线程的执行具有随机性，也就是说t1-t4具体怎么执行
        * 取决于CPU的调度时间片的分配，我们是决定不了的*/
        t1.start();//以多线程的方式启动线程1，将当前线程变为就绪状态
        t2.start();//以多线程的方式启动线程2，将当前线程变为就绪状态
        t3.start();//以多线程的方式启动线程3，将当前线程变为就绪状态
        t4.start();//以多线程的方式启动线程4，将当前线程变为就绪状态
    }
}
//1.自定义一个多线程类，然后让这个类继承Thread
class MyThread extends Thread{
    /*1.多线程编程实现的方案1：通过继承Thread类并重写run()来完成的 */
    //2.重写run(),run()里是我们自己的业务
    @Override
    public void run() {
        /*2.super.run()表示的是调用父类的业务，我们现在要用自己的业务，所以注释掉*/
        //super.run();
        //3.完成业务：打印10次当前正在执行的线程的名称
        for (int i = 0; i < 10; i++) {
            /*3.getName()表示可以获取当前正在执行的线程名称
            * 由于本类继承了Thread类，所以可以直接使用这个方法*/
            System.out.println(i+"="+getName());
        }
    }
}

package cn.tedu.thread;
/*本类用于多线程编程实现方案二：实现Runnable接口来完成*/
public class TestThread2 {
    public static void main(String[] args) {
        //5.创建自定义类的对象--目标业务类对象
        MyRunnable target = new MyRunnable();
        //6.如何启动线程？自己没有，需要与Thread建立关系
        Thread t1 = new Thread(target);
        Thread t2 = new Thread(target);
        Thread t3 = new Thread(target);
        Thread t4 = new Thread(target);
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
//1.自定义多线程类
class MyRunnable implements Runnable{
    //2.添加父接口中的抽象方法run(),里面是自己的业务
    @Override
    public void run() {
        //3.写业务，打印10次当前正在执行的线程名称
        for (int i = 0; i < 10; i++) {
            /*问题：自定义类与父接口Runnable中都没有获取名字的方法
            * 所以还需要从Thread中找：
            * currentThread():静态方法，获取当前正在执行的线程对象
            * getName():获取当前线程的名称*/
            System.out.println(i+"="+Thread.currentThread().getName());
        }
    }
}

package cn.tedu.tickets;
/*需求：设计多线程编程模型，4个窗口共计售票100张
* 本方案使用多线程编程方案1，继承Thread类的方式来完成*/
public class TestThread {
    public static void main(String[] args) {
        //5.创建多个线程对象
        TicketThread t1 = new TicketThread();
        TicketThread t2 = new TicketThread();
        TicketThread t3 = new TicketThread();
        TicketThread t4 = new TicketThread();
        //6.以多线程的方式启动
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
//1.自定义多线程售票类，继承Thread
class TicketThread extends Thread{
    //3.定义变量，保存要售卖的票数
    /*问题：4个线程对象共计售票400张，原因是创建了4次对象，各自操作各自的成员变量
    * 解决：让所有对象共享同一个数据，票数需要设置为静态*/
    static int tickets = 100;
    //2.重写父类的run(),里面是我们的业务
    @Override
    public void run() {
        //4.1循环卖票
        while(true){
            try {
                //7.让每个线程经历休眠，增加线程状态切换的频率与出错的概率
                //问题1：产生了重卖的现象：同一张票卖了多个人
                //问题2：产生了超卖的现象：超出了规定的票数100，出现了0 -1 -2这样的票
                Thread.sleep(10);//让当前线程休眠10ms
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //4.2打印当前正在卖票的线程名称，并且票数-1
            System.out.println(getName()+"="+tickets--);
            //4.3做判断，如果没有票了，就退出死循环
            if(tickets <= 0) break;//注意，死循环一定要设置出口
        }
    }
}

package cn.tedu.tickets;
/*需求：设计多线程编程模型，4个窗口共计售票100张
 * 本方案使用多线程编程方案2，实现Runnable接口的方式来完成*/
public class TestRunnable {
    public static void main(String[] args) {
        //5.创建Runnable接口的实现类对象，作为目标业务对象
        TicketRunnable target = new TicketRunnable();
        //6.创建多个Thread类线程对象，并将target业务对象交给多个线程对象来处理
        Thread t1 = new Thread(target);
        Thread t2 = new Thread(target);
        Thread t3 = new Thread(target);
        Thread t4 = new Thread(target);
        //7.以多线程的方式启动多个线程对象
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}
//1.自定义多线程类实现Runnable接口
class TicketRunnable implements Runnable{
    //3.定义一个成员变量，用来保存票数100
    /*由于自定义类对象只创建了一次，所以票数被所有线程对象Thread类的对象共享*/
    int tickets = 100;
    //2.添加接口中未实现的方法，方法里是我们的业务
    @Override
    public void run() {
        //4.1循环卖票
        while(true){
            //8.让线程休眠10ms,增加线程状态切换的概率和出错的概率
            try {
                Thread.sleep(10);//让当前线程休眠10ms
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //4.2打印当前正在售票的线程名称 & 票数-1
            System.out.println(Thread.currentThread().getName()+"="+tickets--);
            //4.3设置死循环的出口，没票了就停止卖票
            if(tickets <=0 ) break;
        }
    }
}

https://blog.csdn.net/weixin_43884234/article/details/115049704
package cn.tedu.tickets;

/*本类用于改造多线程售票案例，解决数据安全问题*/
public class TestRunnableV2 {
    public static void main(String[] args) {
        //5.创建目标业务类对象
        TicketR2 target = new TicketR2();
        //6.创建线程对象
        Thread t1 = new Thread(target);
        Thread t2 = new Thread(target);
        Thread t3 = new Thread(target);
        Thread t4 = new Thread(target);
        //7.以多线程的方式运行
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}

/*1.多线程中出现数据安全问题的原因：多线程程序+共享数据+多条语句操作共享数据*/
/*2.同步锁：相当于给容易出现问题的代码加了一把锁，包裹了所有可能会出现数据安全问题的代码
 * 加锁之后，就有了同步(排队)的效果，但是加锁的话，需要考虑：
 * 锁的范围：不能太大，太大，干啥都得排队，也不能太小，太小，锁不住，还是会有安全隐患*/
//1.创建自定义多线程类
class TicketR2 implements Runnable {
    //3.定义成员变量，保存票数
    int tickets = 100;
    //创建锁对象
    Object o = new Object();

    //2.实现接口中未实现的方法，run()中放着的是我们的业务
    @Override
    public void run() {
        //4.通过循环结构完成业务
        while (true) {
            /*3.同步代码块：synchronized(锁对象){会出现安全隐患的所有代码}
             * 同步代码块在同一时刻，同一资源只会被一个线程独享*/
            /*这种写法不对，相当于每个线程进来的时候都会new一个锁对象，线程间使用的并不是同一把锁*/
            //synchronized (new Object()){
            //修改同步代码块的锁对象为成员变量o,因为锁对象必须唯一
            synchronized (o) {//同步代码块解决的是重卖的问题
                //如果票数>0就卖票
                if (tickets > 0) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //4.1打印当前正在售票的线程名以及票数-1
                    System.out.println(Thread.currentThread().getName() + "=" + tickets--);
                }
                //4.2退出死循环--没票的时候就结束
                if (tickets <= 0) break;
            }
        }
    }
}

package cn.tedu.tickets;

/*本类用于改造多线程售票案例，解决数据安全问题*/
public class TestThreadV2 {
    public static void main(String[] args) {
        //5.创建多个线程对象并以多线程的方式运行
        TickectT2 t1 = new TickectT2();
        TickectT2 t2 = new TickectT2();
        TickectT2 t3 = new TickectT2();
        TickectT2 t4 = new TickectT2();
        t1.start();
        t2.start();
        t3.start();
        t4.start();
    }
}

//1.自定义多线程类
class TickectT2 extends Thread {
    //3.新增成员变量用来保存票数
    static int tickets = 100;
    //static Object o = new Object();

    //2.添加重写的run()来完成业务
    @Override
    public void run() {
        //3.创建循环结构用来卖票
        while (true) {
            //Ctrl+Alt+L调整代码缩进
            //7.添加同步代码块，解决数据安全问题
            //synchronized (new Object()) {
            /*static的Object的对象o这种写法也可以*/
            //synchronized (o) {
            /*我们每通过class关键字创建一个类，就会在工作空间中生成一个唯一对应的类名.class字节码文件
            * 这个类名.class对应的对象我们称之为这个类的字节码对象
            * 字节码对象极其重要，是反射技术的基石，字节码对象中包含了当前类所有的关键信息
            * 所以，用这样一个唯一且明确的对象作为同步代码块的锁对象，再合适不过了*/
            synchronized (TickectT2.class) {/*比较标准的写法*/
                if(tickets > 0){
                    //6.添加线程休眠，暴露问题
                    try {
                        Thread.sleep(10);//让线程休眠，增加线程状态切换的频率
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //4.1打印当前正在售票的线程名与票数-1
                    System.out.println(getName() + "=" + tickets--);
                }
                //4.2给程序设置一个出口，没有票的时候就停止卖票
                if (tickets <= 0) break;
            }
        }
    }
}

package cn.tedu.tickets;
/*本类用于测试线程池*/
public class TestThreadPool {
    public static void main(String[] args) {
        //5.创建接口实现类TicketR3类的对象作为目标业务对象
        TicketR3 target = new TicketR3();
        /*Executors是用来辅助创建线程池的工具类对象
        * 常用方法是newFixedThreadPool(int)这个方法可以创建指定数目的线程池对象
        * 创建出来的线程池对象是ExecutorService:用来存储线程的池子，负责：新建/启动/关闭线程*/
        //6.使用Executors工具创建一个最多有5个线程的线程池对象ExecutorService池对象
        ExecutorService pool = Executors.newFixedThreadPool(5);
        for (int i = 0; i < 5; i++) {
            /*execute()让线程池中的线程来执行业务，每次调用都会将一个线程加入到就绪队列*/
            pool.execute(target);/*本方法的参数就是你要执行的业务，也就是目标业务类对象*/
        }
    }
}
//同步锁问题解决方案笔记：1.4.1从26行复制到58行，TicketR2改成TicketR3
//1.创建自定义多线程类
class TicketR3 implements Runnable {
    //3.定义成员变量，保存票数
    int tickets = 100;
    //创建锁对象
    Object o = new Object();

    //2.实现接口中未实现的方法，run()中放着的是我们的业务
    @Override
    public void run() {
        //4.通过循环结构完成业务
        while (true) {
            /*3.同步代码块：synchronized(锁对象){会出现安全隐患的所有代码}
             * 同步代码块在同一时刻，同一资源只会被一个线程独享*/
            /*这种写法不对，相当于每个线程进来的时候都会new一个锁对象，线程间使用的并不是同一把锁*/
            //synchronized (new Object()){
            //修改同步代码块的锁对象为成员变量o,因为锁对象必须唯一
            synchronized (o) {//同步代码块解决的是重卖的问题
                //如果票数>0就卖票
                if (tickets > 0) {
                    try {
                        Thread.sleep(10);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    //4.1打印当前正在售票的线程名以及票数-1
                    System.out.println(Thread.currentThread().getName() + "=" + tickets--);
                }
                //4.2退出死循环--没票的时候就结束
                if (tickets <= 0) break;
            }
        }
    }
}

package cn.tedu.thread;
/**
 * 本类用于改造售票案例,使用可重入读写锁
 * ReentrantReadWriteLock
 * */
public class TestSaleTicketsV3 {
	public static void main(String[] args) {
		SaleTicketsV3 target = new SaleTicketsV3();
		Thread t1 = new Thread(target);
		Thread t2 = new Thread(target);
		Thread t3 = new Thread(target);
		Thread t4 = new Thread(target);
		t1.start();
		t2.start();
		t3.start();
		t4.start();
	}
}
class SaleTicketsV3 implements Runnable{
	static int tickets = 100;
	//1.定义可重入读写锁对象,静态保证全局唯一
	static ReentrantReadWriteLock lock = new ReentrantReadWriteLock(true);
	@Override
	public void run() {
		while(true) {
			//2.在操作共享资源前上锁
			lock.writeLock().lock();
			try {
				if(tickets > 0) {
					try {
						Thread.sleep(10);
					} catch (InterruptedException e) {
						e.printStackTrace();
					}
					System.out.println(Thread.currentThread().getName() + "=" + tickets--);
				}
				if(tickets <= 0) break;
			} catch (Exception e) {
				e.printStackTrace();
			}finally {
				//3.finally{}中释放锁,注意一定要手动释放,防止死锁,否则就独占报错了
				lock.writeLock().unlock();
			}
		}
	}
} 

https://blog.csdn.net/Evankaka/article/details/44153709?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522163741453716780265492568%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=163741453716780265492568&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~top_positive~default-1-44153709.pc_v2_rank_blog_default&utm_term=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1018.2226.3001.4450

package com.multithread.learning;
/**
 *@functon 多线程学习
 *@author 林炳文
 *@time 2015.3.9
 */
class Thread1 extends Thread{
	private String name;
    public Thread1(String name) {
       this.name=name;
    }
	public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.println(name + "运行  :  " + i);
            try {
                sleep((int) Math.random() * 10);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
       
	}
}
public class Main {
	public static void main(String[] args) {
		Thread1 mTh1=new Thread1("A");
		Thread1 mTh2=new Thread1("B");
		mTh1.start();
		mTh2.start();

	}
}

/**
 *@functon 多线程学习
 *@author 林炳文
 *@time 2015.3.9
 */
package com.multithread.runnable;
class Thread2 implements Runnable{
	private String name;
 
	public Thread2(String name) {
		this.name=name;
	}
 
	@Override
	public void run() {
		  for (int i = 0; i < 5; i++) {
	            System.out.println(name + "运行  :  " + i);
	            try {
	            	Thread.sleep((int) Math.random() * 10);
	            } catch (InterruptedException e) {
	                e.printStackTrace();
	            }
	        }
		
	}
	
}
public class Main {
 
	public static void main(String[] args) {
		new Thread(new Thread2("C")).start();
		new Thread(new Thread2("D")).start();
	}
 
}

https://blog.csdn.net/maitian_2008/article/details/118582926?spm=1001.2014.3001.5501

class TicketTask implements Runnable{
	   int ticket=10;
	   @Override
	   public void run() {
		    doTicket();
	   }
	   public void doTicket() {
		  while(true) {
			  if(ticket<=0)break;
			  System.out.println(ticket--);
		  }
	   }
   }

public static void main(String[] args) {
	     TicketTask task=new TicketTask();
	     Thread t1=new Thread(task);
	     Thread t2=new Thread(task);
	     Thread t3=new Thread(task);
	     
	     t1.start();
	     t2.start();
	     t3.start();  
   }

class SyncThread implements Runnable {
	private Object obj1;
	private Object obj2;
	public SyncThread(Object o1, Object o2) {
		this.obj1 = o1;
		this.obj2 = o2;
	}
	@Override
	public void run() {
		synchronized (obj1) {
			work();
			synchronized (obj2) {
				work();
			}
		}
	}
	private void work() {
		try {Thread.sleep(30000);} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

public class TestDeadLock01 {
	public static void main(String[] args)throws Exception {
		 Object obj1 = new Object();
		 Object obj2 = new Object();
		 Thread t1 = new Thread(new SyncThread(obj1, obj2), "t1");
		 Thread t2 = new Thread(new SyncThread(obj2, obj1), "t2");
		 t1.start();
		 t2.start();
	}
}

https://blog.csdn.net/weixin_43884234/article/details/115075016?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166342645116800182123502%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=166342645116800182123502&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_ecpm_v1~rank_v31_ecpm-19-115075016-null-null.nonecase&utm_term=%E5%A4%9A%E7%BA%BF%E7%A8%8B&spm=1018.2226.3001.4450
package cn.tedu.net;
/**本类用来表示Socket网络编程案例的服务器端
 * 完成步骤分析:
 * 1.启动服务器
 * 2.接收客户端的连接请求
 * 3.接收客户端发来的数据
 * */
/**测试注意事项:先启动服务器端,再启动客户端*/
public class Server {
	public static void main(String[] args) throws Exception {
		//1.启动服务器,指定端口号为8888,等待客户端的连接
		/**注意:
		 * 1.使用ServerSocket需要导包java.net.ServerSocket
		 * 2.此操作会抛出异常
		 * 3.指定的端口号范围是:0-655535,而0-1024是系统端口号,不能指定
		 * */
		ServerSocket ss = new ServerSocket(8888);
		//2.接收客户端的连接请求,并建立数据通信通道
		Socket socket = ss.accept();
		//3.获取到读取流,接收并读取客户端发来的数据
		InputStream in = socket.getInputStream();
		//通过循环挨个读取显示读到的内容
		for(int i = 0;i < 5;i++) {
			//int b = in.read();//此方法读取的结果是把字符转成数字
			char c = (char) in.read();//为了直接显示读取到的字符,需要强制类型转换(大转小,int转char)
			System.out.print(c);//print()同行输出,注意细节哦
		}
		//5.给客户端发送数据
		OutputStream out = socket.getOutputStream();
		out.write("world".getBytes());
		out.flush();
		
		//4.释放资源
		/**注意关流的顺序,后出现的先关闭*/
		in.close();
		ss.close();
	}
}

package cn.tedu.net;
/**本类用来表示Socket网络编程案例的客户端
 * 完成步骤分析:
 * 1.指定要连接的服务器
 * 2.给服务器发送hello
 * */
public class Client {
	public static void main(String[] args) throws Exception {
		//1.指定要连接的服务器,需要同时指定服务器的IP & Port
		/**注意:
		 * 1.使用Socket需要导包java.net.Socket
		 * 2.此操作会抛出异常
		 * 3.如果使用的是本机的IP,地址是固定值,用来测试时使用127.0.0.1
		 * */
		Socket socket = new Socket("127.0.0.1",8888);
		//2.给服务器端发送hello
		OutputStream out = socket.getOutputStream();
		//把要输出的数据hello字符串转变成byte[]的形式进行输出
		out.write("hello".getBytes());
		out.flush();
		
		//4.读取从服务器端返回的数据
		InputStream in = socket.getInputStream();
		for (int i = 0; i < 5; i++) {
			char c = (char) in.read();//为了显示字符而不是数字,强制类型转换成char
			System.out.print(c);//不换行展示获取到的数据
		}
		
		//3.释放资源
		//out.close();
		socket.close();
		
	}
}

package cn.tedu.net;
/**这个类用来测试一行一行读取,一行一行写出*/
public class TestIO {
	public static void main(String[] args) {
		//method();//初步测试readLine()
		method2();//改进
	}
	public static void method2() {
		BufferedReader in = null;
		PrintWriter out = null;
		try {
			//1.读取一行数据,先拿到读取数据的流,注意文件需要自己在win创建
			in = new BufferedReader(new FileReader("D:\\b.txt"));
			//2.定义变量,记录每行读取到的数据
			String line;
			//3.设置循环读取数据,只要有数据就一直读取
			while( (line=in.readLine()) != null) {
				System.out.println(line);
			}
			
			//4.一行行写出数据:PrintWriter
			out = new PrintWriter(new FileWriter("D:\\b.txt"));
			out.println("java");
			out.println("hello");
			out.flush();//为了防止有数据没有发送过去,可以刷一下
		} catch (Exception e) {
			e.printStackTrace();
		}finally {
			try {
				//5.释放资源
				out.close();
				in.close();
			} catch (IOException e) {
				e.printStackTrace();
			}
		}
	}
	public static void method() {
		try {
			//1.读取一行数据,先拿到读取数据的流,注意文件需要自己在win创建
			BufferedReader in = new BufferedReader(new FileReader("D:\\b.txt"));
			//2.调用readLine方法进行测试
			String line = in.readLine();
			String line2 = in.readLine();
			String line3 = in.readLine();
			//测试1:b.txt没有数据时,readLine()返回null
			//测试2:b.txt有数据,而且是1整行数据,readLine()可以返回整行全部数据
			//测试3:b.txt有数据,而且是多行数据,readLine()只可以返回第1行全部数据
			/**原因:readLine()在读取数据时,会读取特殊标记,换行符\r\n,读到换行符就结束
			 * 结论:readLine()只可以读取1整行数据,如果是多行数据,需要多次调用
			 * */
			//3.打印测试结果
			System.out.println(line);
			System.out.println(line2);
			System.out.println(line3);
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
}

package cn.tedu.net;
/**这个类用来当做回声案例的服务器端
 * 1.启动服务器
 * 2.接收客户端的连接请求
 * 3.给每个用户分配对应的话务员
 * 4.话务员:主要负责和对应的客户端对象进行沟通I/O
 * */
/**1.创建优化后的Server2类,充当服务器端*/
public class Server2 {
	/**2.创建方法,负责服务多个客户*/
	public void service() {
		/**3.匿名对象+匿名内部类(重写run方法)*/
		new Thread() {
			/**5.把业务写在run()中*/
			@Override
			public void run() {
				try {
					//5.1 启动服务器,设置端口号为8000并等待客户端连接
					ServerSocket ss = new ServerSocket(8000);
					System.out.println("服务器启动成功!");
					while(true) {//死循环,一直accept,也就是接受客户端的连接请求
						//5.2 一直接受所有客户端的连接请求
						Socket socket = ss.accept();
						System.out.println("客户端连接成功!");
						//5.3 给每个客户分配自己对应的话务员,1v1
						HuaWuThread t = new HuaWuThread(socket);
						t.start();
					}
				} catch (IOException e) {
					e.printStackTrace();
				}
				
			};
		}.start();/**4.启动线程*/
	}
	
	/**6.创建话务员内部类,主要负责和客户端沟通 I/O*/
	class HuaWuThread extends Thread{
		//6.1 定义本类中的成员变量socket,用来保持通话
		Socket socket;
		//6.2含参构造,接受当前的连接信息,保持通话,为谁服务就保存谁的数据
		public HuaWuThread(Socket socket) {
			this.socket = socket;
		}
		//6.3把话务员的业务放在run(),一直读取客户端发来的数据,并作出回应
		@Override
		public void run() {
			try {
				//7.1读取一行BufferedReader,并且写出一行PrintWriter --双向流
				BufferedReader in = new BufferedReader(
						new InputStreamReader(socket.getInputStream()));
				PrintWriter out = new PrintWriter(
						new OutputStreamWriter(socket.getOutputStream()));
				//7.2读取客户端发来的一行数据
				String line;//定义变量,记录读取到的一行数据
				while((line = in.readLine()) != null) {//只要有数据就一直读
					System.out.println("客户端发来的数据:"+line);
					//7.1可以给客户端作出响应-接收键盘输入的响应
					System.out.println("请输入您的回应:");
					String input = new Scanner(System.in).nextLine();
					//7.2发出作为服务器的响应
					out.println(input);
					out.flush();//把数据刷出去
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	
	public static void main(String[] args) {
		Server2 s = new Server2();
		s.service();
	}
}


—————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


public class ClassTest{
     String str = new String("hello");
     char[] ch = {'a','b','c'};
     public void fun(String str, char ch[]){
     str="world";
     ch[0]='d';
 }
 public static void main(String[] args) {
     ClassTest test1 = new ClassTest();
     test1.fun(test1.str,test1.ch);
     System.out.print(test1.str + " and ");
     System.out.print(test1.ch);
     }
 }
 hello and dbc
 world and abc
 hello and abc
 world and dbc

public class Test {
    public static int aMethod(int i) throws Exception {
        try {
            return i / 10;
        } catch (Exception ex) {
            throw new Exception("exception in a aMethod");
        } finally {
            System.out.printf("finally");
        }
    }

    public static void main(String[] args) {
        try {
            aMethod(0);
        } catch (Exception ex) {
            System.out.printf("exception in main");
        }
        System.out.printf("finished");
    }
}
 exception in main finished
 finallyfinished
 exception in main finally
 finally exception in main finally

public class B {
    public static B t1 = new B();
    public static B t2 = new B();

    {
        System.out.println("构造块");
    }

    static {
        System.out.println("静态块");
    }

    public static void main(String[] args) {
        B t = new B();
    }
}
 静态块 构造块 构造块 构造块
 构造块 静态块 构造块 构造块
 构造块 构造块 静态块 构造块
 构造块 构造块 构造块 静态块

public class MyClass{
    static int i;
    public static void main(String argv[]){
        System.out.println(i);
    }
}
 有错误，变量i没有初始化。
 null
 1
 0

public class Test {
    public static void main(String args[]) {
        int x = -5;
        int y = -12;
        System.out.println(y % x);
    }
}
 -1
 2
 1
 -2

以下代码的循环次数是？
public class Test {
    public static void main(String args[]) {
        int i = 7;
        do {
            System.out.println(--i);
            --i;
        } while (i != 0);
       System.out.println(i);
    }
}
 0
 1
 7
 无限次

public class Test{ 
    private static int i=1;
    public int getNext(){ 
         return i++;
    } 
    public static void main(String [] args){ 
        Test test=new Test(); 
        Test testObject=new Test(); 
        test.getNext(); 
        testObject.getNext(); 
        System.out.println(testObject.getNext()); 
    } 
}
 2
 3
 4
 5

list是一个ArrayList的对象，哪个选项的代码填到//todo delete处，可以在Iterator遍历的过程中正确并安全的删除一个list中保存的对象？
Iterator it = list.iterator();
int index = 0;
while (it.hasNext())
{
    Object obj = it.next();
    if (needDelete(obj))  //needDelete返回boolean，决定是否要删除
    {
        //todo delete
    }
    index ++;
}
 it.remove();
 list.remove(obj);
 list.remove(index);
 list.remove(obj,index);

class Two{
    Byte x;
}
class PassO{
    public static void main(String[] args){
        PassO p=new PassO();
        p.start();
    }
    void start(){
        Two t=new Two();
        System.out.print(t.x+””);
        Two t2=fix(t);
        System.out.print(t.x+” ” +t2.x);
    }
    Two fix(Two tt){
        tt.x=42;
        return tt;
    }
}
 null null 42
 null 42 42
 0 0 42
 0 42 42
 An exception is thrown at runtime
 Compilation





























